"""LangGraph workflow for multi-agent orchestration"""

import logging
from typing import Any, Dict

from langgraph.graph import END, StateGraph

from app.agents.rag import RAGAgent
from app.agents.responder import ResponderAgent
from app.agents.router import RouterAgent
from app.agents.state import ConversationState, Message
from app.agents.tool import ToolAgent

logger = logging.getLogger(__name__)


class AgentOrchestrator:
    """
    Orchestrates multiple agents using LangGraph

    Workflow:
    1. Router classifies intent
    2. Routes to appropriate agent (RAG, Tool, or Responder)
    3. Agent processes and generates response
    """

    def __init__(self):
        # Initialize agents
        self.router = RouterAgent()
        self.rag_agent = RAGAgent()
        self.tool_agent = ToolAgent()
        self.responder = ResponderAgent()

        # Build workflow graph
        self.workflow = self._build_workflow()

    def _build_workflow(self) -> StateGraph:
        """Build LangGraph workflow"""
        workflow = StateGraph(ConversationState)

        # Add nodes
        workflow.add_node("router", self._router_node)
        workflow.add_node("rag", self._rag_node)
        workflow.add_node("tool", self._tool_node)
        workflow.add_node("respond", self._respond_node)

        # Set entry point
        workflow.set_entry_point("router")

        # Add conditional edges from router
        workflow.add_conditional_edges(
            "router",
            self._route_decision,
            {"rag": "rag", "tool": "tool", "respond": "respond"},
        )

        # All specialist agents end
        workflow.add_edge("rag", END)
        workflow.add_edge("tool", END)
        workflow.add_edge("respond", END)

        return workflow.compile()

    async def _router_node(self, state: ConversationState) -> dict:
        """Router node"""
        updated_state = await self.router.run(state)
        return updated_state.model_dump()

    async def _rag_node(self, state: ConversationState) -> dict:
        """RAG agent node"""
        updated_state = await self.rag_agent.run(state)
        return updated_state.model_dump()

    async def _tool_node(self, state: ConversationState) -> dict:
        """Tool agent node"""
        updated_state = await self.tool_agent.run(state)
        return updated_state.model_dump()

    async def _respond_node(self, state: ConversationState) -> dict:
        """Responder agent node"""
        updated_state = await self.responder.run(state)
        return updated_state.model_dump()

    def _route_decision(self, state: ConversationState) -> str:
        """Determine which agent to route to based on intent"""
        next_step = state.next_step or "respond"
        logger.info(f"Routing to: {next_step} (intent: {state.intent})")
        return next_step

    async def process(self, user_message: str, conversation_history: list = None) -> Dict[str, Any]:
        """
        Process user message through agent workflow

        Args:
            user_message: User's message
            conversation_history: Optional conversation history

        Returns:
            Response with metadata
        """
        try:
            # Initialize state
            messages = conversation_history or []
            messages.append(Message(role="user", content=user_message))

            initial_state = ConversationState(messages=messages)

            # Run workflow
            logger.info(f"Processing message: {user_message[:50]}...")
            final_state = await self.workflow.ainvoke(initial_state.model_dump())

            # Extract response
            response_message = (
                final_state.get("response") or final_state["messages"][-1]["content"]
                if final_state.get("messages")
                else "I'm sorry, I couldn't process your request."
            )

            # Build response
            result = {
                "message": response_message,
                "intent": final_state.get("intent"),
                "agent_used": final_state.get("current_agent"),
                "metadata": {
                    "tool_calls": len(final_state.get("tool_calls", [])),
                    "docs_retrieved": len(final_state.get("retrieved_docs", [])),
                    **final_state.get("metadata", {}),
                },
            }

            logger.info(f"Response generated by: {final_state.get('current_agent')}")
            return result

        except Exception as e:
            logger.error(f"Error in orchestration: {e}", exc_info=True)
            return {
                "message": (
                    "I apologize, but I encountered an error processing "
                    "your request. Please try again."
                ),
                "intent": "error",
                "agent_used": "none",
                "metadata": {"error": str(e)},
            }
